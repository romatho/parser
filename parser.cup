package parserClasses;
import java_cup.runtime.*;



parser code
{:
  public Program program;
:};



terminal BOOL, CLASS, DO, ELSE, EXTENDS, FALSE, IF, IN, INT32, ISNULL, LET, NEW, THEN, TRUE, UNIT, WHILE, ASSIGN, OBJECTIDENTIFIER, DOT, INTEGERLITERAL, TYPEIDENTIFIER;

terminal STRING, STRINGLITERAL;

terminal LBRACE, RBRACE, LPAR, RPAR, COLON, SEMICOLON, COMMA;

terminal AND, EQUAL, LOWER, LOWEREQUAL, DIV, NOT, MINUS, PLUS, POW, TIMES;



non terminal Blocks block;
non terminal Class class; /*done*/
non terminal Expression expression;/*done*/
non terminal Fields field;/*done*/
non terminal Formals formals;/*done*/
non terminal Method method; /*done*/
non terminal Program program;/*done*/
non terminal Types types;/*done*/


/*Expression*/
/*non terminal Assign assign;
non terminal BinOp binop;
non terminal Call call;
non terminal If if;
non terminal Let let;
non terminal New new;
non terminal Terminal terminal;
non terminal Unop unop;
non terminal While while;*/


non terminal ParserArray<Class> classArray; /*done*/
non terminal ParserArray<Formals> formalArray;/*done*/
non terminal ParserArray<Fields> fieldsArray;/*done*/
non terminal ParserArray<Methods> methodsArray;/*done*/
non terminal ParserArray<Expressions> expArray; /*done*/


precedence left PLUS, MINUS;

precedence left AND, TIMES, DIV, DOT;

precedence right ELSE, ASSIGN, ISNULL, POW;

precedence nonassoc EQUAL, LOWER, LOWEREQUAL;



start with program;

program ::=     classArray:ca
                {: RESULT = new Program(0,0, ca); :};


classArray::=   classArray:ca Class:c {:ca.add(c); RESULT =ca; :}
                |                     {: RESULT=new ParserArray<Class>() :};


expArray::=   expArray:ea SEMICOLON expression:exp1 {:ea.add(exp1); RESULT = ea; :}
                |                     {: RESULT=new ParserArray<Class>() :};



class::=        CLASS OBJECTIDENTIFIER:name LBRACE fieldsArray:fa methodsArray:ma  RBRACE
                {: RESULT = new Class(0, 0, name.value, parent.value, fa, ma):}
                |CLASS OBJECTIDENTIFIER EXTENDS OBJECTIDENTIFIER:parent LBRACE fieldsArray:fa methodsArray:ma  RBRACE
                {: RESULT = new Class(0, 0, parent, fa, ma):};


fieldsArray::=   fieldsArray:fa fields:f {:fa.add(f); RESULT =fa; :}
                |                     {: RESULT=new ParserArray<Field>() :};

formalArray::=   formalArray:fa formals:f COMMA {:fa.add(f); RESULT =fa; :}
                |                     {: RESULT=new ParserArray<Formals>() :};

methodsArray::=   methodsArray:ma method:m {:ma.add(m); RESULT =ma; :}
                |                     {: RESULT=new ParserArray<Methods>() :};


                /*If*/
expression::=   IF expression:exp1 THEN expression:exp2 ELSE expression:exp3
                {:RESULT = new If(0, 0, exp1.value, exp2.value, exp3.value):}
                |IF expression:exp1 THEN expression:exp2
                {:RESULT = new If(0, 0, exp1.value, exp2.value):}

                /*While*/
                | WHILE expression:exp1 DO expression:exp2
                {:RESULT = new While(0, 0, exp1.value, exp2.value):}

                /*Let*/
                |LET OBJECTIDENTIFIER:oi COLON types ASSIGN expression:exp1 IN expression:exp2
                {:RESULT = new Let(0, 0, oi, exp1.value, exp2.value):}
                |LET OBJECTIDENTIFIER:oi COLON types IN expression:exp1
                {:RESULT = new Let(0, 0, oi, exp1.value):}

                /*Assign*/
                |OBJECTIDENTIFIER:oi ASSIGN expression:exp1
                {:RESULT = new Assign(0, 0, oi, exp1.value):}

                /*UnOp*/
                |NOT expression:exp1
                {:RESULT = new UnOp(0, 0, "not", exp1.value):}
                |MINUS ASSIGN expression:exp1
                {:RESULT = new UnOp(0, 0, "-", exp1.value):}
                |ISNULL expression:exp1
                {:RESULT = new UnOp(0, 0, "isnull", exp1.value):}

                /*BinOp*/
                |expression:exp1 EQUAL expression:exp2
                {:RESULT = new BinOp(0, 0, "=", exp1.value, exp2.value):}
                |expression:exp1 LOWER expression:exp2
                {:RESULT = new BinOp(0, 0, "<", exp1.value, exp2.value):}
                |expression:exp1 LOWEREQUAL expression:exp2
                {:RESULT = new BinOp(0, 0, "<=", exp1.value, exp2.value):}
                |expression:exp1 PLUS expression:exp2
                {:RESULT = new BinOp(0, 0, "+", exp1.value, exp2.value):}
                |expression:exp1 MINUS expression:exp2
                {:RESULT = new BinOp(0, 0, "-", exp1.value, exp2.value):}
                |expression:exp1 TIMES expression:exp2
                {:RESULT = new BinOp(0, 0, "*", exp1.value, exp2.value):}
                |expression:exp1 DIV expression:exp2
                {:RESULT = new BinOp(0, 0, "//", exp1.value, exp2.value):}

                /*Call*/
                |expression:exp1 DOT OBJECTIDENTIFIER LPAR formalArray:fa RPAR
                {:RESULT = new Call(0, 0, exp1.value, oi.value, fa.value):}
                |OBJECTIDENTIFIER:oi LPAR formalArray:fa RPAR
                {:RESULT = new Call(0, 0, "self", oi.value, fa.value):}

                /*New*/
                |NEW LPAR TYPEIDENTIFIER:ti RPAR
                {:RESULT = new New(0, 0, ti.value):}
                |OBJECTIDENTIFIER:oi LPAR formalArray:fa RPAR
                {:RESULT = new Call(0, 0, "self", oi.value, fa.value):}
                /*Call*/
                |expression:exp1 DOT OBJECTIDENTIFIER LPAR formalArray:fa RPAR
                {:RESULT = new Call(0, 0, exp1.value, oi.value, fa.value):}
                |OBJECTIDENTIFIER:oi LPAR formalArray:fa RPAR
                {:RESULT = new Call(0, 0, "self", oi, fa):}

                /*Terminaison*/
                |INTEGERLITERAL:it
                {:RESULT = new Call(0, 0, it.value):}
                |STRINGLITERAL:sl
                {:RESULT = new Call(0, 0, sl.value):}
                |TRUE
                {:RESULT = new Call(0, 0, "true"):}
                |FALSE
                {:RESULT = new Call(0, 0, "false"):};


field::=        OBJECTIDENTIFIER:oi COLON types:t SEMICOLON
                {:RESULT = new Field(0,0,oi,t,null) :}
                |OBJECTIDENTIFIER:oi COLON types:t ASSIGN expression:e SEMICOLON
                {:RESULT = new Field(0,0,oi,t,e) :};

formals::=      OBJECTIDENTIFIER:oi COLON types:t
                {:RESULT =new Formals(0,0,oi,t) :};



types::=        types:t {:RESULT =new Types(0,0,t):}
                | INT32
                {: RESULT = new Types(0,0,"int32") :}
                | BOOL
                {: RESULT = new Types(0,0,"bool") :}
                | STRING
                {: RESULT = new Types(0,0,"string") :}
                | UNIT
                {: RESULT = new Types(0,0,"unit") :};



method::=       OBJECTIDENTIFIER:oi LPAR formalArray:fa RPAR COLON types:t block:b
                {RESULT = new Method(0, 0, oi.value, fa, t, b)};


block::=    LBRACE   expArray:ea  RBRACE {:RESULT = new Blocks(0,0,ea):};

