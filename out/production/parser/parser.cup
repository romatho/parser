package parserClasses;
import java_cup.runtime.*;



parser code
{:
  public Program program;
:};



terminal BOOL, CLASS, DO, ELSE, EXTENDS, FALSE, IF, IN, INT32, ISNULL, LET, NEW, THEN, TRUE, UNIT, WHILE, ASSIGN, DOT;

terminal String STRING, STRINGLITERAL, OBJECTIDENTIFIER, INTEGERLITERAL, TYPEIDENTIFIER;

terminal LBRACE, RBRACE, LPAR, RPAR, COLON, SEMICOLON, COMMA;

terminal AND, EQUAL, LOWER, LOWEREQUAL, DIV, NOT, MINUS, PLUS, POW, TIMES;



non terminal Blocks block;
non terminal Class class; /*done*/
non terminal Expressions expression;/*done*/
non terminal Field field; /*done*/
non terminal Formals formals; /*done*/
non terminal Method method; /*done*/
non terminal Program program; /*done*/
non terminal Types types; /*done*/
non terminal ClassBody classBody;


/*Expression*/
/*non terminal Assign assign;
non terminal BinOp binop;
non terminal Call call;
non terminal If if;
non terminal Let let;
non terminal New new;
non terminal Unop unop;
non terminal While while;*/
non terminal Terminal terminaison, boolean;
non terminal Terminal objectid;

non terminal ParserArray<Class> classArray; /*done*/
non terminal ParserArray<Formals> formalArray;/*done*/
non terminal ParserArray<Field> fieldsArray;/*done*/
non terminal ParserArray<Method> methodsArray;/*done*/
non terminal ParserArray<Expressions> expArray, argArray, argOthers; /*done*/


precedence left PLUS, MINUS;

precedence left AND, TIMES, DIV, DOT;

precedence right ASSIGN, ISNULL, POW, OBJECTIDENTIFIER;

precedence left EQUAL;

precedence nonassoc LOWER, LOWEREQUAL, IF;

precedence nonassoc ELSE;

start with program;

program ::=     classArray:ca
                {: System.out.println("program"); RESULT = new Program(0,0, ca); :};

classArray::=   classArray:ca class:c {: System.out.println(c.toString()); ca.add(c); RESULT = ca; :}
                |                     {: System.out.println("classArray2"); RESULT = new ParserArray<Class>(); :};

expArray::=     expArray:ea expression:exp1 SEMICOLON {:System.out.println("expArray1"); ea.add(exp1); System.out.println(ea.toString()); RESULT = ea; :}
                |                     {: System.out.println("expArray3"); RESULT = new ParserArray<Expressions>(); :};


class::=        CLASS TYPEIDENTIFIER:name LBRACE classBody:bd  RBRACE
                {: System.out.println("class1"); RESULT = new Class(0, 0, name, bd );:}
                |CLASS TYPEIDENTIFIER:name EXTENDS TYPEIDENTIFIER:parent LBRACE classBody:bd  RBRACE
                {: System.out.println("class2"); RESULT = new Class(0, 0, name, parent, bd);:};

classBody::=    classBody:cb   field:f
                {:System.out.println("add field to class body"); cb.addField(f);System.out.println("add field to class body"); RESULT=cb; :}
                |classBody:cb method:m
                {:System.out.println("add method to class body"); cb.addMethod(m);System.out.println("add field to class body"); RESULT=cb;:}
                |
                {:RESULT = new ClassBody(0,0); :};

fieldsArray::=   fieldsArray:fa field:f {:System.out.println("fieldArray1"); fa.add(f);System.out.println(fa.toString()); RESULT =fa; :}
                |                       {: System.out.println("fieldArray2"); RESULT=new ParserArray<Field>(); :};

formalArray::=  formalArray:fa formals:f  COMMA{: System.out.println("formalArray1"); fa.add(f); RESULT =fa; :}
                |                     {: System.out.println("formalArray2"); RESULT=new ParserArray<Formals>(); :};

methodsArray::=   methodsArray:ma method:m {:System.out.println("methodArray1"); ma.add(m); RESULT =ma; :}
                |                     {: System.out.println("methodArray2"); RESULT=new ParserArray<Method>(); :};


                /*If*/
expression::=   IF expression:exp1 THEN expression:exp2 ELSE expression:exp3
                {:RESULT = new If(0, 0, exp1, exp2, exp3); :}
                |IF expression:exp1 THEN expression:exp2
                {:RESULT = new If(0, 0, exp1, exp2); :}
                | LPAR expression:exp1 RPAR
                {:RESULT = exp1; :}
                /*While*/
                | WHILE expression:exp1 DO expression:exp2
                {:RESULT = new While(0, 0, exp1, exp2); :}

                /*Let*/
                |LET OBJECTIDENTIFIER:oi COLON types:ti ASSIGN expression:exp1 IN expression:exp2
                {:RESULT = new Let(0, 0, oi, ti, exp1, exp2); :}
                |LET OBJECTIDENTIFIER:oi COLON types:ti IN expression:exp1
                {:RESULT = new Let(0, 0, oi, ti, exp1); :}

                /*Assign*/
                |OBJECTIDENTIFIER:oi ASSIGN expression:exp1
                {:RESULT = new Assign(0, 0, oi, exp1); :}

                /*UnOp*/
                |NOT expression:exp1
                {:RESULT = new UnOp(0, 0, "not", exp1); :}
                |MINUS expression:exp1
                {:RESULT = new UnOp(0, 0, "-", exp1); :}
                |ISNULL expression:exp1
                {:RESULT = new UnOp(0, 0, "isnull", exp1); :}

                /*BinOp*/
                |expression:exp1 EQUAL expression:exp2
                {:RESULT = new BinOp(0, 0, "=", exp1, exp2); :}
                |expression:exp1 LOWER expression:exp2
                {:RESULT = new BinOp(0, 0, "<", exp1, exp2); :}
                |expression:exp1 LOWEREQUAL expression:exp2
                {:RESULT = new BinOp(0, 0, "<=", exp1, exp2); :}
                |expression:exp1 PLUS expression:exp2
                {:RESULT = new BinOp(0, 0, "+", exp1, exp2); :}
                |expression:exp1 MINUS expression:exp2
                {:RESULT = new BinOp(0, 0, "-", exp1, exp2); :}
                |expression:exp1 TIMES expression:exp2
                {:RESULT = new BinOp(0, 0, "*", exp1, exp2); :}
                |expression:exp1 POW expression:exp2
                {:RESULT = new BinOp(0, 0, "^", exp1, exp2); :}
                |expression:exp1 DIV expression:exp2
                {:RESULT = new BinOp(0, 0, "//", exp1, exp2); :}
                |expression:exp1 AND expression:exp2
                {:RESULT = new BinOp(0, 0, "AND", exp1, exp2); :}

                /*Call*/
                |OBJECTIDENTIFIER:oi LPAR argArray:aa RPAR
                {:RESULT = new Call(0, 0, new Terminal(0, 0, "self"), oi, aa); :}
                |expression:exp1 DOT OBJECTIDENTIFIER:oi LPAR argArray:aa RPAR
                {:RESULT = new Call(0, 0, exp1, oi, aa); :}

                /*New*/
                |NEW LPAR types:ti RPAR
                {:RESULT = new New(0, 0, ti);:}

                |terminaison:ter
                {:RESULT = ter; :};

                /*Terminaison*/

terminaison::=  INTEGERLITERAL:it
                {:System.out.println("terminaison1"); RESULT = new Terminal(0, 0, it); :}
                |STRINGLITERAL:sl
                {:System.out.println("terminaison2"); RESULT = new Terminal(0, 0, sl); :}
                |OBJECTIDENTIFIER:oi
                {:System.out.println("terminaison1522"); RESULT = new Terminal(0, 0, oi); :}
                |boolean:b
                {:System.out.println("bool"); RESULT = b; :};

boolean::=      TRUE
                {:System.out.println("bool1"); RESULT = new Terminal(0, 0, "true"); :}
                |FALSE
                {:System.out.println("bool2"); RESULT = new Terminal(0, 0, "false"); :};


field::=        OBJECTIDENTIFIER:oi COLON types:t SEMICOLON
                {: System.out.println("Field1"); RESULT = new Field(0,0,oi,t,null); :}
                |OBJECTIDENTIFIER:oi COLON types:t ASSIGN expression:e SEMICOLON
                {:System.out.println("Field2"); RESULT = new Field(0,0,oi,t,e); :};

formals::=      OBJECTIDENTIFIER:oi COLON types:t
                {:System.out.println("formals1"); RESULT = new Formals(0,0,oi,t); :};




types::=        TYPEIDENTIFIER:t {:System.out.println("type1"); RESULT = new Types(0,0,t); :}
                | INT32
                {: System.out.println("type2"); RESULT = new Types(0,0,"int32"); :}
                | BOOL
                {: System.out.println("type3"); RESULT = new Types(0,0,"bool"); :}
                | STRING
                {: System.out.println("type4"); RESULT = new Types(0,0,"string"); :}
                | UNIT
                {: System.out.println("type5"); RESULT = new Types(0,0,"unit"); :};



method::=       OBJECTIDENTIFIER:oi LPAR formalArray:fa formals:f RPAR COLON types:t block:b
                {:System.out.println("method");fa.add(f); RESULT = new Method(0, 0, oi, fa, t, b); :}
                |OBJECTIDENTIFIER:oi LPAR  RPAR COLON types:t block:b
                                 {:System.out.println("method2"); RESULT = new Method(0, 0, oi, null, t, b); :};


block::=        LBRACE expArray:ea expression:exp1 RBRACE
                {:System.out.println("block"); ea.add(exp1); System.out.println(ea.toString()); RESULT = new Blocks(0,0,ea); :};

argArray::=     argOthers:args expression:exp1
                {:args.add(exp1); RESULT=args;:}
                |
                {:RESULT=new ParserArray<Expressions>(); :};

argOthers::=    argOthers:args expression:exp1 COMMA
                {:args.add(exp1); RESULT=args; :}
                |
                {:RESULT=new ParserArray<Expressions>(); :};